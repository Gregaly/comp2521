Input Size	Initial Order	Has 	No.	Avg Time 	Avg Time
				Dupli-	Runs	useIntList	sort
				cates
	
1000		random		no	5	0.0		0.0
1000		sorted		no	5	0.01		0.0
1000		reversed	no	5	0.0		0.0
1000		random		yes	5	0.002		0.0
1000		sorted		yes	5	0.01		0.0
1000		reversed	yes	5	0.0		0.0
2000		random		no	5	0.01		0.0
2000		sorted		no	5	0.02		0.0
2000		reversed	no	5	0.0		0.0
2000		random		yes	5	0.01		0.0
2000		sorted		yes	5	0.02		0.0
2000		reversed	yes	5	0.01		0.0
3000		random		no	5	0.02		0.0
3000		sorted		no	5	0.04		0.0
3000		reversed	no	5	0.0		0.0
3000		random		yes	5	0.02		0.0
3000		sorted		yes	5	0.04		0.0
3000		reversed	yes	5	0.02		0.0
4000		random		no	5	0.04		0.0
4000		sorted		no	5	0.07		0.0
4000		reversed	no	5	0.0		0.0
4000		random		yes	5	0.04		0.0
4000		sorted		yes	5	0.07		0.0
4000		reversed	yes	5	0.04		0.0
5000		random		no	5	0.06		0.0
5000		sorted		no	5	0.11		0.0
5000		reversed	no	5	0.0		0.0
5000		random		yes	5	0.06		0.0
5000		sorted		yes	5	0.11		0.0
5000		reversed	yes	5	0.06		0.0
6000		random		no	5	0.09		0.0
6000		sorted		no	5	0.15		0.0
6000		reversed	no	5	0.01		0.0
6000		random		yes	5	0.09		0.0
6000		sorted		yes	5	0.16		0.0
6000		reversed	yes	5	0.09		0.0
7000		random		no	5	0.12		0.0
7000		sorted		no	5	0.21		0.0
7000		reversed	no	5	0.01		0.0
7000		random		yes	5	0.12		0.0
7000		sorted		yes	5	0.21		0.0
7000		reversed	yes	5	0.12		0.0
8000		random		no	5	0.16		0.0
8000		sorted		no	5	0.27		0.0
8000		reversed	no	5	0.01		0.0
8000		random		yes	5	0.16		0.0
8000		sorted		yes	5	0.27		0.0
8000		reversed	yes	5	0.16		0.0
9000		random		no	5	0.2		0.0
9000		sorted		no	5	0.34		0.0
9000		reversed	no	5	0.01		0.0
9000		random		yes	5	0.21		0.0
9000		sorted		yes	5	0.35		0.0
9000		reversed	yes	5	0.21		0.0
10000		random		no	5	0.26		0.0
10000		sorted		no	5	0.42		0.0
10000		reversed	no	5	0.01		0.0
10000		random		yes	5	0.27		0.0
10000		sorted		yes	5	0.42		0.0
10000		reversed	yes	5	0.26		0.0
15000		random		no	5	0.67		0.0
15000		sorted		no	5	0.94		0.0
15000		reversed	no	5	0.01		0.0
15000		random		yes	5	0.66		0.0
15000		sorted		yes	5	0.94		0.0
15000		reversed	yes	5	0.66		0.0
20000		random		no	5	1.3		0.0
20000		sorted		no	5	1.7		0.0
20000		reversed	no	5	0.02		0.0
20000		random		yes	5	1.3		0.0
20000		sorted		yes	5	1.7		0.0
20000		reversed	yes	5	1.3		0.0
25000		random		no	5	2.1		0.01
25000		sorted		no	5	2.6		0.0
25000		reversed	no	5	0.02		0.0
25000		random		yes	5	2.1		0.0
25000		sorted		yes	5	2.6		0.0
25000		reversed	yes	5	2.1		0.0
30000		random		no	5	3.1		0.01
30000		sorted		no	5	3.7		0.0
30000		reversed	no	5	0.03		0.0
30000		random		yes	5	3.1		0.0
30000		sorted		yes	5	3.7		0.0
30000		reversed	yes	5	3.1		0.0
35000		random		no	5	4.4		0.01
35000		sorted		no	5	5.1		0.0
35000		reversed	no	5	0.03		0.0
35000		random		yes	5	4.4		0.0
35000		sorted		yes	5	5.1		0.0
35000		reversed	yes	5	4.4		0.0
40000		random		no	5	5.8		0.01
40000		sorted		no	5	6.8		0.0
40000		reversed	no	5	0.034		0.0
40000		random		yes	5	6.1		0.0
40000		sorted		yes	5	6.7		0.0
40000		reversed	yes	5	5.8		0.0
45000		random		no	5	7.6		0.01
45000		sorted		no	5	8.9		0.002
45000		reversed	no	5	0.04		0.01
45000		random		yes	5	7.7		0.0
45000		sorted		yes	5	8.5		0.0
45000		reversed	yes	5	8.5		0.0
50000		random		no	5	11.0		0.02
50000		sorted		no	5	12.0		0.01
50000		reversed	no	5	0.044		0.01
50000		random		yes	5	11.0		0.0
50000		sorted		yes	5	11.0		0.0
50000		reversed	yes	5	10.0		0.0
55000		random		no	5	15.0		0.022
55000		sorted		no	5	13.0		0.01
55000		reversed	no	5	0.05		0.01
55000		random		yes	5	13.0		0.0
55000		sorted		yes	5	14.0		0.0
55000		reversed	yes	5	12.0		0.0
60000		random		no	5	14.0		0.02
60000		sorted		no	5	15.0		0.01
60000		reversed	no	5	0.05		0.01
60000		random		yes	5	14.0		0.0
60000		sorted		yes	5	15.0		0.0
60000		reversed	yes	5	14.0		0.0
65000		random		no	5	17.0		0.02
65000		sorted		no	5	19.0		0.01
65000		reversed	no	5	0.06		0.01
65000		random		yes	5	19.0		0.0
65000		sorted		yes	5	18.0		0.0
65000		reversed	yes	5	17.0		0.0
70000		random		no	5	20.0		0.03
70000		sorted		no	5	20.0		0.01
70000		reversed	no	5	0.066		0.012
70000		random		yes	5	19.0		0.0
70000		sorted		yes	5	20.0		0.0
70000		reversed	yes	5	19.0		0.0
75000		random		no	5	23.0		0.03
75000		sorted		no	5	23.0		0.01
75000		reversed	no	5	0.06		0.01
75000		random		yes	5	23.0		0.0
75000		sorted		yes	5	23.0		0.0
75000		reversed	yes	5	23.0		0.0
80000		random		no	5	26.0		0.03
80000		sorted		no	5	27.0		0.01
80000		reversed	no	5	0.07		0.01
80000		random		yes	5	27.0		0.0
80000		sorted		yes	5	27.0		0.0
80000		reversed	yes	5	26.0		0.0
85000		random		no	5	30.0		0.03
85000		sorted		no	5	30.0		0.01
85000		reversed	no	5	0.07		0.012
85000		random		yes	5	31.0		0.0
85000		sorted		yes	5	30.0		0.0
85000		reversed	yes	5	31.0		0.0
90000		random		no	5	35.0		0.04
90000		sorted		no	5	34.0		0.01
90000		reversed	no	5	0.08		0.02
90000		random		yes	5	35.0		0.0
90000		sorted		yes	5	34.0		0.0
90000		reversed	yes	5	35.0		0.0
95000		random		no	5	40.0		0.04
95000		sorted		no	5	38.0		0.01
95000		reversed	no	5	0.08		0.02
95000		random		yes	5	41.0		0.0
95000		sorted		yes	5	38.0		0.0
95000		reversed	yes	5	40.0		0.0
100000		random		no	5	46.0		0.04
100000		sorted		no	5	42.0		0.02
100000		reversed	no	5	0.082		0.02
100000		random		yes	5	46.0		0.0
100000		sorted		yes	5	42.0		0.0
100000		reversed	yes	5	47.0		0.0

Graphing the time/size graphs for all three types of data: unsorted, sorted and reversed, resulted in two different types of graph. For the default sort utility in linux, the graphs of all three types resulted in realtionship that looked similar to linear (O(n)). The sort utility implements a mergesort, an algorithm that has 0(nlogn) time complexity. This is likely due to the fact that with input sizes of max 100,000, log_2(100,000) = 17, this factor is negligible. 

On the other hand, our useIntList executible resulted in different graphs for the three different data given. For random and sorted data, the relationship was quadratic: as the input size increased, the time increased with a quadratic relationship, that is, the rate of change increased linearily as the input size increased. This is because our useIntList uses a insertion sort, that is for each new element inserted, it traversed the entire list and finds the correct position to insert the element into. For random data, this requires traversing the list for up to the entire length, resulting in a worst case scenario of n squared, as it must traverse the entire input list for each element to insert. When fed sorted data from smallest to biggest, the algorithm actually ran slowest, since values are fed into the IntListInsertInOrder function in the right order (smallest to biggest), requiring the algorithm to traverse the entire list for each element in order to find the correct position and resulting in the worst time for all cases. However, the reversed data set results in the elements being fed into our IntListInsertInOrder function() in the reversed order (from biggest -> smallest), allowing to be inserted in the immediate beginning rather than having to traverse the array. Because of this, it remained close to the speed of the sort utility.

As for lists containing duplicates, times remained relatively consistent for random and sorted lists, yet different drastically for reversed lists using our useIntList function. This occured due to our use of the condition "currentNode->data > v" to sort data. For example, if adding "3" to a list containing 100 "3" elements, the algorithm would have to iterate through each of the 100 "3"'s as opposed to inserting it instantly as it would with a non-duplicated reversed list. Finally, timing data from the regular sort algorithm shows "0.0s" regardless of the data size (up to 100000). This is likely due to the mergesort continually splitting the list. When there are large sections of duplicated values, it no longer has to further split these sections, saving time on an already extremely quick and efficient algorithm.